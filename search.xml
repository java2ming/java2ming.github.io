<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>java常见面试题【1】</title>
      <link href="/2018/06/08/java-interview-1/"/>
      <url>/2018/06/08/java-interview-1/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>近期再找工作,复习一波面试题，整理一下常见的Java面试题</p></blockquote><a id="more"></a><h4> ArrayList的默认长度</h4><br>&gt; ArrayList的底层是由一个Object[]数组构成的，而这个Object[]数组，默认的长度是10,size()方法，指的是“逻辑”长度。<br>所谓“逻辑”长度，是指内存已存在的“实际元素的长度” 而“空元素不被计算”<br>        即：当你利用add()方法，向ArrayList内添加一个“元素”时，逻辑长度就增加1位。 而剩下的9个空元素不被计算。<br>        每次增长 (旧容量*3/2)+1<br><br><h4> Lock与synchronized 的区别</h4><blockquote><ol><li>线程A和B都要获取对象O的锁定，假设A获取了对象O锁，B将等待A释放对O的锁定，<br> 如果使用 synchronized ，如果A不释放，B将一直等下去，不能被中断<br>如果使用 ReentrantLock，如果A不释放，可以使B在等待了足够长的时间以后，中断等待，而干别的事情</li><li>synchronized是在JVM层面上实现的，不但可以通过一些监控工具监控synchronized的锁定，而且在代码执行时出现异常，JVM会自动释放锁定，但是使用Lock则不行，lock是通过代码实现的，要保证锁定一定会被释放，就必须将unLock()放到finally{}中</li><li>在资源竞争不是很激烈的情况下，Synchronized的性能要优于ReetrantLock，但是在资源竞争很激烈的情况下，Synchronized的性能会下降几十倍，但是ReetrantLock的性能能维持常态</li></ol></blockquote><h4>mysql索引类型</h4><br>1. 普通索引<br>2. 唯一索引<br>3. 主键索引<br>4. 组合索引<br>5. 全文索引<br><br><h4>事务特性</h4><blockquote><p>事务特性分为四个：原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）、持续性（Durability）简称ACID。</p></blockquote><ul><li><strong>原子性（Atomicity）</strong>:   事务是数据库逻辑工作单元，事务中包含的操作要么都执行成功，要么都执行失败。</li><li><strong>一致性（Consistency）</strong>： 事务执行的结果必须是使数据库数据从一个一致性状态变到另外一种一致性状态。当事务执行成功后就说数据库处于一致性状态。如果在执行过程中发生错误，这些未完成事务对数据库所做的修改有一部分已写入物理数据库，这是数据库就处于不一致状态。</li><li><strong>隔离性（Isolation）</strong>：一个事务的执行过程中不能影响到其他事务的执行，即一个事务内部的操作及使用的数据对其他事务是隔离的，并发执行各个事务之间无不干扰。</li><li><strong>持续性（Durability）</strong>：即一个事务执一旦提交，它对数据库数据的改变是永久性的。之后的其它操作不应该对其执行结果有任何影响。</li></ul><h4>事务的隔离级别</h4><blockquote><ol><li>事务的隔离级别也分为四种，由低到高依次分别为：</li></ol><ul><li><strong>read uncommited（读未提交）</strong>：是最低的事务隔离级别，它允许另外一个事务可以看到这个事务未提交的数据。</li><li><strong>read commited（读提交）</strong>：保证一个事物提交后才能被另外一个事务读取。另外一个事务不能读取该事物未提交的数据。</li><li><strong>read repeatable（读重复）</strong>：这种事务隔离级别可以防止脏读，不可重复读。但是可能会出现幻象读。它除了保证一个事务不能被另外一个事务读取未提交的数据之外还避免了以下情况产生（不可重复读）。</li><li><strong>serializable（序列化）</strong>：这是花费最高代价但最可靠的事务隔离级别。事务被处理为顺序执行。除了防止脏读，不可重复读之外，还避免了幻象读。</li></ul></blockquote><blockquote><ol start="2"><li>脏读、不可重复读、幻象读概念说明：</li></ol><ul><li><strong>脏读</strong>：指当一个事务正字访问数据，并且对数据进行了修改，而这种数据还没有提交到数据库中，这时，另外一个事务也访问这个数据，然后使用了这个数据。因为这个数据还没有提交那么另外一个事务读取到的这个数据我们称之为脏数据。依据脏数据所做的操作肯能是不正确的。</li><li><strong>不可重复读</strong>：指在一个事务内，多次读同一数据。在这个事务还没有执行结束，另外一个事务也访问该同一数据，那么在第一个事务中的两次读取数据之间，由于第二个事务的修改第一个事务两次读到的数据可能是不一样的，这样就发生了在一个事物内两次连续读到的数据是不一样的，这种情况被称为是不可重复读。</li><li><strong>幻读</strong>：一个事务先后读取一个范围的记录，但两次读取的纪录数不同，我们称之为幻象读（两次执行同一条 select 语句会出现不同的结果，第二次读会增加一数据行，并没有说这两次执行是在同一个事务中）</li></ul></blockquote><p></p><h4>spring事务传播特性</h4><br>    &gt; 事务传播行为就是多个事务方法相互调用时，事务如何在这些方法间传播。spring支持7种事务传播行为：<p></p><ul><li><strong>propagation_requierd</strong>：如果当前没有事务，就新建一个事务，如果已存在一个事务中，加入到这个事务中，这是最常见的选择。</li><li><strong>propagation_supports</strong>：支持当前事务，如果没有当前事务，就以非事务方法执行。</li><li><strong>propagation_mandatory</strong>：使用当前事务，如果没有当前事务，就抛出异常。</li><li><strong>propagation_required_new</strong>：新建事务，如果当前存在事务，把当前事务挂起。</li><li><strong>propagation_not_supported</strong>：以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。</li><li><strong>propagation_never</strong>：以非事务方式执行操作，如果当前事务存在则抛出异常。</li><li><strong>propagation_nested</strong>：如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则执行与propagation_required类似的操作<blockquote><p>Spring 默认的事务传播行为是 PROPAGATION_REQUIRED，它适合于绝大多数的情况。假设 ServiveX#methodX() 都工作在事务环境下（即都被 Spring 事务增强了），假设程序中存在如下的调用链：Service1#method1()-&gt;Service2#method2()-&gt;Service3#method3()，那么这 3 个服务类的 3 个方法通过 Spring 的事务传播机制都工作在同一个事务中。</p></blockquote></li></ul><p></p><h4>SQL数据库中的范式</h4><br>    &gt; 事务传播行为就是多个事务方法相互调用时，事务如何在这些方法间传播。spring支持7种事务传播行为：<p></p><ul><li><p><strong>第一范式（1NF）</strong>：强调的是列的原子性，即列不能够再分成其他几列。</p><blockquote><p>考虑这样一个表：【联系人】（姓名，性别，电话）<br>如果在实际场景中，一个联系人有家庭电话和公司电话，那么这种表结构设计就没有达到 1NF。要符合 1NF 我们只需把列（电话）拆分，即：【联系人】（姓名，性别，家庭电话，公司电话）。1NF 很好辨别，但是 2NF 和 3NF 就容易搞混淆。</p></blockquote></li><li><p><strong>第二范式（2NF）</strong>：首先是 1NF，另外包含两部分内容，一是表必须有一个主键；二是没有包含在主键中的列必须完全依赖于主键，而不能只依赖于主键的一部分。</p><blockquote><p>考虑一个订单明细表：【OrderDetail】（OrderID，ProductID，UnitPrice，Discount，Quantity，ProductName）。<br>因为我们知道在一个订单中可以订购多种产品，所以单单一个 OrderID 是不足以成为主键的，主键应该是（OrderID，ProductID）。显而易见 Discount（折扣），Quantity（数量）完全依赖（取决）于主键（OderID，ProductID），而 UnitPrice，ProductName 只依赖于 ProductID。所以 OrderDetail 表不符合 2NF。不符合 2NF 的设计容易产生冗余数据。<br>可以把【OrderDetail】表拆分为【OrderDetail】（OrderID，ProductID，Discount，Quantity）和【Product】（ProductID，UnitPrice，ProductName）来消除原订单表中UnitPrice，ProductName多次重复的情况。</p></blockquote></li><li><p><strong>第三范式（3NF）</strong>：首先是 2NF，另外非主键列必须直接依赖于主键，不能存在传递依赖。即不能存在：非主键列 A 依赖于非主键列 B，非主键列 B 依赖于主键的情况。</p><blockquote><p>考虑一个订单表【Order】（OrderID，OrderDate，CustomerID，CustomerName，CustomerAddr，CustomerCity）主键是（OrderID）。<br>其中 OrderDate，CustomerID，CustomerName，CustomerAddr，CustomerCity 等非主键列都完全依赖于主键（OrderID），所以符合 2NF。不过问题是 CustomerName，CustomerAddr，CustomerCity 直接依赖的是 CustomerID（非主键列），而不是直接依赖于主键，它是通过传递才依赖于主键，所以不符合 3NF。<br>通过拆分【Order】为【Order】（OrderID，OrderDate，CustomerID）和【Customer】（CustomerID，CustomerName，CustomerAddr，CustomerCity）从而达到 3NF。</p></blockquote><p>  第二范式（2NF）和第三范式（3NF）的概念很容易混淆，区分它们的关键点在于，2NF：非主键列是否完全依赖于主键，还是依赖于主键的一部分；3NF：非主键列是直接依赖于主键，还是直接依赖于非主键列。</p></li></ul><p></p><h4>JDK并发包 java.util.concurrent</h4><br><img src="https://raw.githubusercontent.com/java2ming/image/master/java/concurrent/1.jpg" alt="Alt text"><p></p><blockquote><p>外层框架主要有Lock(ReentrantLock、ReadWriteLock等)、同步器（semaphores等）、阻塞队列（BlockingQueue等）、Executor（线程池）、并发容器（ConcurrentHashMap等）、还有Fork/Join框架；<br>内层有AQS（AbstractQueuedSynchronizer类，锁功能都由他实现）、非阻塞数据结构、原子变量类(AtomicInteger等无锁线程安全类)三种。<br>底层就实现是volatile和CAS。整个并发包其实都是由这两种思想构成的。</p></blockquote><p></p><h4>JDK8新特性</h4><p></p><blockquote><p> <strong>Lambda 表达式</strong> − Lambda允许把函数作为一个方法的参数（函数作为参数传递进方法中)。<br>    <strong>方法引用</strong> − 方法引用提供了非常有用的语法，可以直接引用已有Java类或对象（实例）的方法或构造器。与lambda联合使用，方法引用可以使语言的构造更紧凑简洁，减少冗余代码。<br>    <strong>默认方法</strong> − 默认方法就是一个在接口里面有了一个实现的方法。新增了default方法和static方法，这两种方法可以有方法体<br>    <strong>新工具 − 新的编译工具</strong>，如：Nashorn引擎 jjs、 类依赖分析器jdeps。<br>    <strong>Stream API</strong> −新添加的Stream API（java.util.stream） 把真正的函数式编程风格引入到Java中。<br>    <strong>Date Time API</strong> − 加强对日期与时间的处理。<br>    <strong>Optional 类</strong> − Optional 类已经成为 Java 8 类库的一部分，用来解决空指针异常。<br>    <strong>Nashorn, JavaScript 引擎</strong> − Java 8提供了一个新的Nashorn javascript引擎，它允许我们在JVM上运行特定的javascript应用。</p></blockquote><p></p><h4>UDP、TCP区别</h4><p></p><blockquote><p>TCP是建立可靠连接，并且通信双方都可以以流的形式发送数据。相对TCP，UDP则是面向无连接的协议。<br>使用UDP协议时，不需要建立连接，只需要知道对方的IP地址和端口号，就可以直接发数据包。但是，能不能到达就不知道了。<br>虽然用UDP传输数据不可靠，但它的优点是和TCP比，速度快，对于不要求可靠到达的数据，就可以使用UDP协议。</p></blockquote>]]></content>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 面试题 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>pjax: 当ajax遇上pushState</title>
      <link href="/0201/02/12/about-pjax/"/>
      <url>/0201/02/12/about-pjax/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>var pjax = pushState + ajax;<br>小时候，小浣熊方便面里面有各种水浒人物的卡片。我买了一包，吃了方便面，饱了。而我又买了第二包，不是想吃方便面，而是仅仅想得到里面的卡片…          </p></blockquote><a id="more"></a><p>##<strong>一、简介</strong><br>pushState是html5中提供的方法，用以</p><ul><li>无刷新的更新浏览器地址栏；            </li><li>如其名称，将新地址push到历史堆栈中            </li></ul><p>用法：<code>pushState(data, title ,url)</code>            </p><p>data为保存的对象，可以在window.onpopstate时获取到；title为页面标题；url为需地址栏和历史发生改变的url。<br>正是这点看似很平常的功能，跟ajax结合到一起产生了火花。因为，ajax最擅长的事情就是局部刷新页面。</p><p>##<strong>二、ajax的纠结历史</strong><br>一切可以从ajax最擅长的事情说起。<br>ajax作为一个异步请求模型，从最初设计开始，也许压根就没打算将它跟浏览器历史挂钩。原因是历史堆栈所记录的，某种意思上可以说是顺序，跟我们理解的“同步”更为密切。</p><p>因而，<code>ajax可以无刷新改变页面内容，却无法改变页面的url</code>。</p><ul><li>####历史问题1 - 如何操控历史</li></ul><p>当单页面越来越流行，操作记录却很容易被忽略。假设有这样的单页面，按照分类点击，界面逐层递进：<code>体育 - 篮球 -nba -马刺队 - 邓肯</code><br>当我们点了4下到“邓肯”界面时，一个不小心的刷新，出现在你面前的也许是“体育”。原因是操作记录没有被记录。<br>而通常的解决方案是修改hash，每递进一层，去更新url的hash值，这样的方法：</p><ol><li>刷新时预先判断url的hash，从而知道这是哪一层，加载相应数据；          </li><li>支持了历史</li></ol><p>这样的方式貌似比较完善，其实不然。</p><ul><li>####历史问题2 - 对搜索引擎不友好</li></ul><p>最大的问题是，hash后生成的内容是不会被搜索引擎引用到。数据不能被爬取，无疑是浪费和损失。因此google放言，咱可以约定个协议：<code>#!xxx</code>这样hash的url，google也去爬取。称之为<code>hash bang</code>（哈希大爆炸？）。这一协议，在g+，twitter，人人，新浪微博上都可以看到。</p><p>事实上，ajax最或缺的两个问题，恰好被pushState的功能补充完善。</p><p>##<strong>三、pjax带来的价值</strong><br>除去补齐了ajax的问题，我们发现pjax会给web带来更多的好处。<br>回到开始说的“两包方便面”，我的意思是，有时你访问两个url，部分数据是相同的。比如百度贴吧，第一页和第二页的区别只是帖子内容（卡片）的不同，网站外框部分（方便面）都是一样的，这些东西就不需要在页面刷新时重复加载。</p><p>ajax处理这样的局部刷新，已经给我们带来了web2.0的体验，而加上pushstate的ajax则更进一步：</p><ol><li>一个url对应一套数据，有利于SEO；</li><li>更改数据和url时，只是局部刷新，带来较好的用户体验；</li><li>兼容性好，对不支持pushstate的浏览器，url也能正常请求页面（虽然有重复加载）；</li><li>刷新页面时，由于是url唯一，能正常加载到用户希望看到的数据，比处理hash的方式更方便；</li><li>后退与前进的浏览器操作，依然可以局部刷新（通过onpushstate事件捕获）</li></ol><p>##<strong>四、注意事项</strong></p><p>然而pjax不等于单纯的分离使用pushstate与ajax，还必须得做一些封装。缘于以下我能想到的注意事项：</p><ul><li>服务器端增加额外处理逻辑<br>服务器端，需要根据请求的参数，作出全页渲染或局部渲染响应<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Accept:text/html, */*; q=0.01</span><br><span class="line">Accept-Encoding:gzip,deflate,sdch</span><br><span class="line">Connection:keep-alive</span><br><span class="line">Host:qianduannotes.duapp.com</span><br><span class="line">User-Agent:AppleWebKit/537.36 (KHTML, like Gecko) Chrome/31.0.1650.63 Safari/537.36</span><br><span class="line">X-Requested-With:XMLHttpRequest</span><br><span class="line">X-PJAX:true</span><br></pre></td></tr></table></figure></li></ul><p>比如请求头部可以设定一个X-PAJX:true，用以通知服务器。</p><ul><li><p>浏览器兼容<br>假如浏览器不支持pushstate，提供fallback操作，直接打开需更改url的地址：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$.support.pjax = window.history &amp;&amp; window.history.pushState</span><br><span class="line">// Fallback</span><br><span class="line">if ( !$.support.pjax ) &#123;</span><br><span class="line">  $.pjax = function( options ) &#123;</span><br><span class="line">    window.location = $.isFunction(options.url) ? options.url() : options.url</span><br><span class="line">  &#125;</span><br><span class="line">  $.fn.pjax = function() &#123; return this &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>本地存储机制<br>无疑pjax与localstorage共同使用可以进一步提升体验，但这一步容易忽略的是数据上报。</p></li></ul><p>##<strong>五、参考资料</strong><br><a href="https://github.com/defunkt/jquery-pjax" target="_blank" rel="noopener">jquery-pjax</a><br><a href="https://github.com/welefen/pjax" target="_blank" rel="noopener">welefen封装的pjax</a></p>]]></content>
      
      
        <tags>
            
            <tag> js </tag>
            
            <tag> html5 </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
